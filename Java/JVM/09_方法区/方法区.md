# 方法区

 ## 1.栈、堆、方法区的交互关系

### 运行时数据区结构图

![image-20201004093304096](方法区.assets/image-20201004093304096.png)

- 从线程共享与否的角度来看

  ![image-20201004093645484](方法区.assets/image-20201004093645484.png)

- 从创建对象的角度来看

  ![image-20201004094012012](方法区.assets/image-20201004094012012.png)

## 2.方法区的理解

### 方法区在哪里？

《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但是一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”  但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。

所以，**方法区看作是一块独立于Java堆的内存空间**

![image-20201004095239101](方法区.assets/image-20201004095239101.png)

### 方法区的基本理解

- 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域
- 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间和Java堆区一样都可以是不连续的
- 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展
- 方法区的大小决定了系统弄可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError:**PermGen space**或者java.lang,OutOfMemoryError: **Metaspace**
  - 加载了大量的第三方的jar包；Tomcat部署的工程过多（30-50个）；大量动态的生成反射类
- 关闭JVM就会释放这个区域的内存

### HotSpot中方法区的演进

- 在JDK7及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代

  ![image-20201004100218057](方法区.assets/image-20201004100218057.png)

- 本质上，方法区和永久代并不等价。仅是对HotSpot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit/IBM J9中不存在永久代的概念

  - 现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM（超过-XX:MaxPermSize上限）

### 方法区概述

![image-20201004100853868](方法区.assets/image-20201004100853868.png)

### HotSpot中方法区的演进

- 而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替。

  ![image-20201004101821795](方法区.assets/image-20201004101821795.png)

- 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：**元空间不在虚拟机设置的内存中，而是使用本地内存**

- 永久代、元空间二者并不只是名字变了，内部结构也调整了

- 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常

## 3.设置方法区大小与OOM

- 方法区的大小不必是固定的，jvm可以根据应用的需要动态调整

- JDK7及以前：

  - **通过-XX:PermSize来设置永久代初始分配空间。默认值是20.75M**

  - -XX:MaxPermSize来设定永久代最大可分配空间。32位机器默认是64m，64位机器默认是82m

  - 当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError：Permspace

    ![image-20201004103529701](方法区.assets/image-20201004103529701.png)

- JDK8及以后：

  - 元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定，代替上述原有的两个参数
  - 默认值依赖于平台。**windows下，-XX:MetaspaceSize是21m，-XX:MaxMetaspaceSize的值是-1，即没有限制**
  - 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有可以用的系统内存。如果元数据区发生泄漏，虚拟机一样会抛出异常OutOfMemoryError：Metaspace
  - -XX:MetaspaceSize设置初始的元空间大小，对于一个64位的服务器端的JVM来说，其默认的-XX:MetaspaceSize的值为21M。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线会被重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值
  - 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁GC，建议将-XX:MetaspaceSize设置为一个相对较高的值
  
  举例：
  
  ```java
  /**
   * jdk6中：
   * -XX:PermSize=5m -xx:MaxPermSize=5m
   *
   * jdk8中：
   * -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m
   * @author CQ
   */
  public class OOMTest extends ClassLoader {
      public static void main(String[] args) {
          int j = 0;
          try {
              OOMTest test = new OOMTest();
              for (int i = 0; i < 10000; i++) {
                  //创建classwriter对象，用于生成类的二进制字节码
                  ClassWriter classWriter = new ClassWriter(0);
                  //指明版本号、修饰符、类名、包名、父类、接口
                  classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, "Class" + i, null, "java/lang/Object", null);
                  //返回byte[]
                  byte[] code = classWriter.toByteArray();
                  //类的加载
                  test.defineClass("Class" + i, code, 0, code.length);
                  j++;
              }
          } finally {
              System.out.println(j);
          }
      }
  }
  ```
  
  ![image-20201004154520605](方法区.assets/image-20201004154520605.png)

### 如何解决这些OOM

1. 要解决OOM异常或Heap space的异常，一般的手段是首先通过内存映射分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要分析清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）

2. 如果内存泄漏，可以进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确的定位出泄漏代码的位置

   > 常说的GC(Garbage Collector) roots，特指的是垃圾收集器（Garbage Collector）的对象，GC会收集那些不是GC roots且没有被GC roots引用的对象。
   >
   > 一个对象可以属于多个root，GC root有几下种：
   >
   > - **Class** - 由系统类加载器(system class loader)加载的对象，这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象。我们需要注意的一点就是，通过用户自定义的类加载器加载的类，除非相应的java.lang.Class实例以其它的某种（或多种）方式成为roots，否则它们并不是roots，.
   > - **Thread** - 活着的线程
   > - **Stack Local** - Java方法的local变量或参数
   > - **JNI Local** - JNI方法的local变量或参数
   > - **JNI Global** - 全局JNI引用
   > - **Monitor Used** - 用于同步的监控对象
   > - **Held by JVM** - 用于JVM特殊目的由GC保留的对象，但实际上这个与JVM的实现是有关的。可能已知的一些类型是：系统类加载器、一些JVM知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。**然而，JVM并没有为这些对象提供其它的信息，因此需要去确定哪些是属于"JVM持有"的了。**

3. 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗

## 4.方法区的内部结构

![image-20201004160042966](方法区.assets/image-20201004160042966.png)

### 方法区（Method Area）存储什么

- 《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的**类型信息、常量、静态变量、即时编译器编译后的代码缓存等**。

  ![image-20201004160339498](方法区.assets/image-20201004160339498.png)

**类型信息**

- 对每个加载的类型（类Class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储一下类型信息：
  1. 这个类型的完整有效名称（全名=包名.类名）
  2. 这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）
  3. 这个类型的修饰符（public、abstract、final的某个子集）
  4. 这个类型直接接口的一个有序列表

**域（Field）信息**

- JVM必须在方法区中保存类型的所有域的相关信息及域的声明顺序
- 域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient的某个子集）

**方法（Method）信息**

- JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：
  - 方法名称
  - 方法的返回类型（或void）
  - 方法参数的数量和类型（按顺序）
  - 方法的修饰符（public、private、protected、static、final、synchronized、native、abstract的一个子集）
  - 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）
  - 异常表（abstract和native方法除外）
    - 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引











## 5.方法区使用举例

## 6.方法区的演进细节

## 7.方法区的垃圾回收

## 8.总结



